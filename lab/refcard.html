<title>GNU Emacs Reference Card (for version 19)</title>

<h1>GNU Emacs Reference Card</h1>
<em>(for version 19)</em>

<h2>Note:</h2>
The PDF version of this reference card is at
<A
HREF="refcard-emacs.pdf">www.cs.colorado.edu/~main/cs1300/lab/refcard-emacs.pdf</A>.
<BR>
The gdb reference card is at
<A HREF="refcard-gdb.pdf">www.cs.colorado.edu/~main/cs1300/lab/refcard-gdb.pdf</A>.

<h2>Starting  Emacs</h2>


To enter GNU Emacs 19, just type its name: <tt><i>emacs</i></tt>, or
type <tt><I>emacs</i></tt> followed by a filename to edit a particular file.



<h2>Leaving  Emacs</h2>

<pre>
suspend Emacs (or iconify it under X)              C-z
exit Emacs permanently                             C-x C-c
</pre>


<h2><a name="files">Files</a></h2>

<pre>
read a file into Emacs                             C-x C-f
save a file back to disk                           C-x C-s
save all files                                     C-x s
insert contents of another file into this buffer   C-x i
replace this file with the file you really want    C-x C-v
write buffer to a specified file                   C-x C-w
</pre>


<h2>Getting  Help</h2>


The Help system is simple. Type <tt>C-h</tt> and follow the directions. If
you are a first-time user, type <tt>C-h t</tt> for a tutorial.

<pre>
remove Help window                                 C-x 1
scroll Help window                                 ESC C-v

apropos: show commands matching a string           C-h a
show the function a key runs                       C-h c
describe a function                                C-h f
get mode-specific information                      C-h m
</pre>


<h2>Error  Recovery</h2>

<pre>
abort partially typed or executing command         C-g
recover a file lost by a system crash              M-x recover-file
undo an unwanted change                            C-x u or C-`
restore a buffer to its original contents          M-x revert-buffer
redraw garbaged screen                             C-l
</pre>


<h2>Incremental  Search</h2>

<pre>
search forward                                     C-s
search backward                                    C-r
regular expression search                          C-M-s
reverse regular expression search                  C-M-r

select previous search string                      M-p
select next later search string                    M-n
exit incremental search                            RET
undo effect of last character                      DEL
abort current search                               C-g
</pre>

Use <tt>C-s</tt> or <tt>C-r</tt> again to repeat the search in either
direction.  If Emacs is still searching, <tt>C-g</tt> cancels only the
part not done.



<h2>Motion</h2>

<pre>
entity to move over                        backward      forward

character                                  C-b           C-f
word                                       M-b           M-f
line                                       C-p           C-n
go to line beginning (or end)              C-a           C-e
sentence                                   M-a           M-e
paragraph                                  M--           M-"
page                                       C-x [         C-x ]
sexp                                       C-M-b         C-M-f
function                                   C-M-a         C-M-e
go to buffer beginning (or end)            M-<           M->

scroll to next screen                              C-v
scroll to previous screen                          M-v
scroll left                                        C-x <
scroll right                                       C-x >
scroll current line to center of screen            C-u C-l
</pre>


<h2>Killing  and  Deleting</h2>

<pre>
entity to kill                             backward      forward
character (delete, not kill)               DEL           C-d
word                                       M-DEL         M-d
line (to end of)                           M-0 C-k       C-k
sentence                                   C-x DEL       M-k
sexp                                       M-- C-M-k     C-M-k

kill region                                        C-w
copy region to kill ring                           M-w
kill through next occurrence of char               M-z char

yank back last thing killed                        C-y
replace last yank with previous kill               M-y
</pre>


<h2>Marking</h2>

<pre>
set mark here                                      C-@ or C-SPC
exchange point and mark                            C-x C-x

set mark arg words away                            M-@
mark paragraph                                     M-h
mark page                                          C-x C-p
mark sexp                                          C-M-@
mark function                                      C-M-h
mark entire buffer                                 C-x h
</pre>


<h2>Query  Replace</h2>

<pre>
interactively replace a text string                M-%
using regular expressions             		   M-x query-replace-regexp
</pre>

Valid responses in query-replace mode are:

<pre>
replace this one, go on to next                    SPC
replace this one, don't move                       ,
skip to next without replacing                     DEL
replace all remaining matches                      !
back up to the previous match                      ^
exit query-replace                                 ESC
enter recursive edit (C-M-c to exit)               C-r
</pre>


<h2>Multiple  Windows</h2>

<pre>
delete all other windows                           C-x 1
delete this window                                 C-x 0
split window in two vertically                     C-x 2

split window in two horizontally                   C-x 3

scroll other window                                C-M-v
switch cursor to another window                    C-x o

shrink window shorter                         M-x shrink-window
grow window taller                                 C-x ^
shrink window narrower                             C-x -
grow window wider                                  C-x "

select buffer in other window                      C-x 4 b
display buffer in other window                     C-x 4 C-o
find file in other window                          C-x 4 f
find file read-only in other window                C-x 4 r
run Dired in other window                          C-x 4 d
find tag in other window                           C-x 4 .
</pre>

<h2>Formatting</h2>

<pre>
indent current line (mode-dependent)               TAB
indent region (mode-dependent)                     C-M-"
indent sexp (mode-dependent)                       C-M-q
indent region rigidly arg columns                  C-x TAB

insert newline after point                         C-o
move rest of line vertically down                  C-M-o
delete blank lines around point                    C-x C-o
join line with previous (with arg, next)           M-^
delete all white space around point                M-"
put exactly one space at point                     M-SPC

fill paragraph                                     M-q
set fill column                                    C-x f
set prefix each line starts with                   C-x .
</pre>


<h2>Case  Change</h2>

<pre>
uppercase word                                     M-u
lowercase word                                     M-l
capitalize word                                    M-c

uppercase region                                   C-x C-u
lowercase region                                   C-x C-l
capitalize region                                  M-x capitalize-region
</pre>

<h2>The  Minibuffer</h2>


The following keys are defined in the minibuffer:

<pre>
complete as much as possible                       TAB
complete up to one word                            SPC
complete and execute                               RET
show possible completions                          ?
fetch previous minibuffer input                    M-p
fetch next later minibuffer input                  M-n
regexp search backward through history             M-r
regexp search forward through history              M-s
abort command                                      C-g
</pre>

Type <tt>C-x ESC ESC</tt> to edit and repeat the last command that used
the minibuffer. The following keys are then defined:

<pre>
previous minibuffer command                        M-p
next minibuffer command                            M-n
</pre>


<h2>Buffers</h2>

<pre>
select another buffer                              C-x b
list all buffers                                   C-x C-b
kill a buffer                                      C-x k
</pre>


<h2>Transposing</h2>

<pre>
transpose characters                               C-t
transpose words                                    M-t
transpose lines                                    C-x C-t
transpose sexps                                    C-M-t
</pre>


<h2>Spelling  Check</h2>

<pre>
check spelling of current word                     M-$
check spelling of all words in region              M-x ispell-region
check spelling of entire buffer                    M-x ispell-buffer
</pre>


<h2>Tags</h2>

<pre>
find a tag (a definition)                          M-.
find next occurrence of tag                        C-u M-.
specify a new tags file                            M-x visit-tags-table

regexp search on all files in tags table           M-x tags-search
run query-replace on all the files                 M-x tags-query-replace
continue last tags search or query-replace         M-,
</pre>


<h2>Shells</h2>

<pre>
execute a shell command                            M-!
run a shell command on the region                  M-_
filter region through a shell command              C-u M-_
start a shell in window *shell*                    M-x shell
</pre>


<h2>Rectangles</h2>

<pre>
copy rectangle to register                         C-x r r
kill rectangle                                     C-x r k
yank rectangle                                     C-x r y
open rectangle, shifting text right                C-x r o
blank out rectangle                                M-x clear-rectangle
prefix each line with a string                     M-x string-rectangle
</pre>


<h2>Abbrevs</h2>

<pre>
add global abbrev                                  C-x a g
add mode-local abbrev                              C-x a l
add global expansion for this abbrev               C-x a i g
add mode-local expansion for this abbrev           C-x a i l
explicitly expand abbrev                           C-x a e

expand previous word dynamically                   M-/
</pre>


<h2>Regular  Expressions</h2>

<pre>
any single character except a newline              .   (dot)

zero or more repeats                               *
one or more repeats                                +
zero or one repeat                                 ?
any character in the set                           [ : : :]
any character not in the set                       [^ : : :]
beginning of line                                  ^
end of line                                        $
quote a special character c                        "c
alternative ("or")                                 "_
grouping                                           "( : : :")
nth group                                          "n
beginning of buffer                                "`
end of buffer                                      "'
word break                                         "b
not beginning or end of word                       "B
beginning of word                                  "<
end of word                                        ">
any word-syntax character                          "w
any non-word-syntax character                      "W
character with syntax c                            "sc
character with syntax not c                        "Sc
</pre>


<h2>Registers</h2>

<pre>
save region in register                            C-x r s
insert register contents into buffer               C-x r i

save value of point in register                    C-x r SPC
jump to point saved in register                    C-x r j
</pre>


<h2>Info</h2>

<pre>
enter the Info documentation reader                C-h i
</pre>

Moving within a node:

<pre>
   scroll forward                                  SPC
   scroll reverse                                  DEL
   beginning of node                               .   (dot)
</pre>

Moving between nodes:

<pre>
   next node                                       n
   previous node                                   p
   move up                                         u
   select menu item by name                        m
   select nth menu item by number (1-5)            n
   follow cross reference (return with l)          f
   return to last node you saw                     l
   return to directory node                        d
   go to any node by name                          g
</pre>

Other:

<pre>
   run Info tutorial                               h
   list Info commands                              ?
   quit Info                                       q
   search nodes for regexp                         s
</pre>


<h2>Keyboard  Macros</h2>

<pre>
start defining a keyboard macro                    C-x (

end keyboard macro definition                      C-x )
execute last-defined keyboard macro                C-x e
append to last keyboard macro                      C-u C-x (
name last keyboard macro                           M-x name-last-kbd-macro
insert Lisp definition in buffer                   M-x insert-kbd-macro
</pre>


<h2>Commands  Dealing  with  Emacs  Lisp</h2>

<pre>
eval sexp before point                             C-x C-e
eval current defun                                 C-M-x
eval region                                        M-x eval-region
eval entire buffer                                 M-x eval-current-buffer
read and eval minibuffer                           M-ESC
re-execute last minibuffer command                 C-x ESC ESC
read and eval Emacs Lisp file                      M-x load-file
load from standard system directory                M-x load-library
</pre>


<h2>Simple  Customization</h2>


Here are some examples of binding global keys in Emacs Lisp. Note
that you cannot say <tt>""M-#"</tt>; you must say <tt>""e#"</tt>.

<pre>
(global-set-key ""C-cg" 'goto-line)
(global-set-key ""C-x"C-k" 'kill-region)
(global-set-key ""e#" 'query-replace-regexp)
</pre>

An example of setting a variable in Emacs Lisp:

<pre>
(setq backup-by-copying-when-linked t)
</pre>


<h2>Writing  Commands</h2>

<pre>
(defun command-name  (args)
   "documentation"
   (interactive "template")
   body)
</pre>

An example:

<pre>
(defun this-line-to-top-of-window (line)
   "Reposition line point is on to top of window.
With ARG, put point on line ARG.
Negative counts from bottom."
   (interactive "P")
   (recenter (if (null line)
                    0
                 (prefix-numeric-value line))))
</pre>

The argument to interactive is a string specifying how to get the
arguments when the function is called interactively.  Type <tt>C-h f</tt>
interactive for more information.



<pre>



           Copyright c 1993 Free Software Foundation, Inc.
              designed by Stephen Gildea, May 1993 v2.0
              for GNU Emacs version 19 on Unix systems
</pre>
<h5>
Permission is granted to make and distribute copies of this card provided the 
copyright notice and this permission notice are preserved on all copies.
</h5>
<h5>
For copies of the GNU Emacs manual, write to the Free Software Foundation, 
Inc., 675 Massachusetts Ave, Cambridge MA 02139.
</h5>
